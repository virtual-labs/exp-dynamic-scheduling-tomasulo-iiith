{
  "version": 2.0,
  "questions": [
    {
      "question": "After observing the Tomasulo simulation, which factor most significantly limits instruction-level parallelism?",
      "answers": {
        "a": "The number of available reservation stations",
        "b": "The speed of the Common Data Bus",
        "c": "True data dependencies (RAW hazards) between instructions",
        "d": "The complexity of the register renaming logic"
      },
      "explanations": {
        "a": "Partially correct but not the most significant factor. Reservation stations cause structural hazards.",
        "b": "Incorrect. The CDB bandwidth is typically not the primary bottleneck.",
        "c": "Correct. True data dependencies create unavoidable dependencies that limit how much parallelism can be extracted from instruction sequences.",
        "d": "Incorrect. Register renaming complexity doesn't limit ILP; it enables it."
      },
      "correctAnswer": "c",
      "difficulty": "advanced"
    },
    {
      "question": "Based on your simulation experience, what happens when an instruction in a reservation station receives its missing operand via the CDB?",
      "answers": {
        "a": "The instruction immediately begins execution",
        "b": "The instruction becomes ready for execution and waits for a free functional unit",
        "c": "The instruction is moved to a different reservation station",
        "d": "The instruction updates its result and broadcasts on the CDB"
      },
      "explanations": {
        "a": "Incorrect. The instruction must also have a free functional unit available.",
        "b": "Correct. Once all operands are available, the instruction becomes ready but still needs an available functional unit to begin execution.",
        "c": "Incorrect. Instructions stay in their assigned reservation stations.",
        "d": "Incorrect. Receiving operands doesn't cause broadcasting; completing execution does."
      },
      "correctAnswer": "b",
      "difficulty": "intermediate"
    },
    {
      "question": "In your simulation, what did you observe when multiple instructions write to the same architectural register?",
      "answers": {
        "a": "The processor stalls until the first write completes",
        "b": "Only the last issued instruction is allowed to proceed",
        "c": "Each write gets a different reservation station tag, eliminating the false dependency",
        "d": "The processor raises an exception for the conflicting writes"
      },
      "explanations": {
        "a": "Incorrect. The Tomasulo algorithm doesn't stall for WAW hazards.",
        "b": "Incorrect. All instructions proceed; register renaming handles the conflict.",
        "c": "Correct. Register renaming assigns different reservation station tags, allowing both writes to proceed independently.",
        "d": "Incorrect. WAW hazards are handled transparently by register renaming."
      },
      "correctAnswer": "c",
      "difficulty": "intermediate"
    },
    {
      "question": "What performance metric did you notice improved most with out-of-order execution compared to in-order execution?",
      "answers": {
        "a": "Single instruction execution time",
        "b": "Cache hit rate",
        "c": "Overall instruction throughput (IPC)",
        "d": "Branch prediction accuracy"
      },
      "explanations": {
        "a": "Incorrect. Individual instruction execution times remain the same.",
        "b": "Incorrect. Cache performance is independent of instruction scheduling.",
        "c": "Correct. Out-of-order execution increases instruction throughput by overlapping independent operations and utilizing functional units more efficiently.",
        "d": "Incorrect. Branch prediction is orthogonal to the Tomasulo algorithm."
      },
      "correctAnswer": "c",
      "difficulty": "intermediate"
    },
    {
      "question": "During the simulation, when would you expect to see the highest utilization of reservation stations?",
      "answers": {
        "a": "When executing independent instructions with no dependencies",
        "b": "When executing a long chain of dependent instructions",
        "c": "When executing only memory operations",
        "d": "When the functional units have very short execution latencies"
      },
      "explanations": {
        "a": "Incorrect. Independent instructions execute quickly and don't accumulate in reservation stations.",
        "b": "Correct. Dependent instructions queue up in reservation stations waiting for their operands, leading to high utilization.",
        "c": "Incorrect. Memory operations alone wouldn't fill all types of reservation stations.",
        "d": "Incorrect. Short latencies would actually reduce reservation station utilization."
      },
      "correctAnswer": "b",
      "difficulty": "advanced"
    }
  ]
}
